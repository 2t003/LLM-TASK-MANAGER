# =============================================================================
# Pipeline CI/CD — Cloud Build
#
# Déclencheur : push / merge sur `main`
# Conforme à ARCHITECTURE.md § Pipeline CI/CD
#
# Étapes :
#   1. Install dépendances + run tests (pytest)
#   2. Build image Docker
#   3. Push vers Artifact Registry
#   4. Deploy sur Cloud Run (europe-west1) avec connexion Cloud SQL
#   5. Vérification post-deploy (/health)
#
# Variables de substitution à configurer dans le trigger Cloud Build :
#   _REGION                    : europe-west1 (défaut)
#   _SERVICE_NAME              : llm-task-manager (défaut)
#   _REPOSITORY                : llm-task-manager (défaut)
#   _IMAGE_NAME                : llm-task-manager (défaut)
#   _INSTANCE_CONNECTION_NAME  : <PROJECT_ID>:europe-west1:<INSTANCE_NAME>
#   _DB_USER                   : postgres (ou user dédié)
#   _DB_NAME                   : llm_task_manager
#   _API_KEY_SECRET            : nom du secret dans Secret Manager
# =============================================================================

# --- Variables de substitution (configurables dans le trigger Cloud Build) ---
substitutions:
  _REGION: europe-west1
  _SERVICE_NAME: llm-task-manager
  _REPOSITORY: llm-task-manager
  _IMAGE_NAME: llm-task-manager
  _INSTANCE_CONNECTION_NAME: ""       # ex: mon-projet:europe-west1:llm-task-db
  _DB_USER: "postgres"
  _DB_NAME: "llm_task_manager"
  _API_KEY_SECRET: "llm-task-manager-api-key"

options:
  logging: CLOUD_LOGGING_ONLY

steps:
  # ------------------------------------------------------------------
  # Étape 1 — Installation des dépendances et lancement des tests
  # ------------------------------------------------------------------
  - id: "test"
    name: "python:3.11-slim"
    entrypoint: "bash"
    args:
      - "-c"
      - |
        pip install --no-cache-dir --upgrade pip
        pip install --no-cache-dir .[test]
        pytest -q --tb=short
    waitFor: ["-"]  # Commence immédiatement

  # ------------------------------------------------------------------
  # Étape 2 — Build de l'image Docker
  # ------------------------------------------------------------------
  - id: "build"
    name: "gcr.io/cloud-builders/docker"
    args:
      - "build"
      - "-t"
      - "${_REGION}-docker.pkg.dev/${PROJECT_ID}/${_REPOSITORY}/${_IMAGE_NAME}:${SHORT_SHA}"
      - "-t"
      - "${_REGION}-docker.pkg.dev/${PROJECT_ID}/${_REPOSITORY}/${_IMAGE_NAME}:latest"
      - "."
    waitFor: ["test"]  # Build seulement si les tests passent

  # ------------------------------------------------------------------
  # Étape 3 — Push vers Artifact Registry
  # ------------------------------------------------------------------
  - id: "push"
    name: "gcr.io/cloud-builders/docker"
    args:
      - "push"
      - "--all-tags"
      - "${_REGION}-docker.pkg.dev/${PROJECT_ID}/${_REPOSITORY}/${_IMAGE_NAME}"
    waitFor: ["build"]

  # ------------------------------------------------------------------
  # Étape 4 — Déploiement sur Cloud Run avec connexion Cloud SQL
  #
  # --add-cloudsql-instances : crée un socket Unix /cloudsql/<instance>
  #   que l'app utilise via DATABASE_URL ou les variables DB_*
  #
  # Secrets : DB_PASSWORD injecté depuis Secret Manager
  # ------------------------------------------------------------------
  - id: "deploy"
    name: "gcr.io/google.com/cloudsdktool/cloud-sdk"
    entrypoint: "gcloud"
    args:
      - "run"
      - "deploy"
      - "${_SERVICE_NAME}"
      - "--image"
      - "${_REGION}-docker.pkg.dev/${PROJECT_ID}/${_REPOSITORY}/${_IMAGE_NAME}:${SHORT_SHA}"
      - "--region"
      - "${_REGION}"
      - "--platform"
      - "managed"
      - "--allow-unauthenticated"
      - "--port"
      - "8080"
      # --- Scaling (cf. ARCHITECTURE.md § Configuration de scaling) ---
      - "--min-instances"
      - "0"
      - "--max-instances"
      - "5"
      - "--concurrency"
      - "20"
      - "--cpu"
      - "1"
      - "--memory"
      - "512Mi"
      # --- Connexion Cloud SQL (socket Unix) ---
      - "--add-cloudsql-instances"
      - "${_INSTANCE_CONNECTION_NAME}"
      # --- Variables d'environnement ---
      - "--set-env-vars"
      - "PYTHONUNBUFFERED=1,DB_USER=${_DB_USER},DB_NAME=${_DB_NAME},INSTANCE_CONNECTION_NAME=${_INSTANCE_CONNECTION_NAME}"
      # --- Secrets depuis Secret Manager ---
      - "--update-secrets"
      - "DB_PASSWORD=${_API_KEY_SECRET}-db-password:latest,API_KEY=${_API_KEY_SECRET}:latest"
    waitFor: ["push"]

  # ------------------------------------------------------------------
  # Étape 5 — Vérification post-deploy (/health)
  # ------------------------------------------------------------------
  - id: "healthcheck"
    name: "gcr.io/google.com/cloudsdktool/cloud-sdk"
    entrypoint: "bash"
    args:
      - "-c"
      - |
        # Attendre quelques secondes que le service se stabilise
        sleep 5
        SERVICE_URL=$(gcloud run services describe ${_SERVICE_NAME} \
          --region=${_REGION} \
          --format='value(status.url)')
        echo "Service URL: $${SERVICE_URL}"
        # Retry logic (3 tentatives, utile après cold start)
        for i in 1 2 3; do
          STATUS=$(curl -s -o /dev/null -w "%{http_code}" "$${SERVICE_URL}/health")
          echo "Attempt $${i}: /health returned $${STATUS}"
          if [ "$${STATUS}" = "200" ]; then
            echo "SUCCESS: /health returned 200"
            exit 0
          fi
          sleep 5
        done
        echo "FAILED: /health did not return 200 after 3 attempts"
        exit 1
    waitFor: ["deploy"]

# Image à pousser (déclaration pour Cloud Build)
images:
  - "${_REGION}-docker.pkg.dev/${PROJECT_ID}/${_REPOSITORY}/${_IMAGE_NAME}:${SHORT_SHA}"
  - "${_REGION}-docker.pkg.dev/${PROJECT_ID}/${_REPOSITORY}/${_IMAGE_NAME}:latest"
